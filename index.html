<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Waajk Surfer - GOD TIER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Titan+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Titan One', cursive;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-score-box {
            text-align: right;
        }

        .hud-label {
            font-size: 14px;
            color: #bdc3c7;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            text-shadow: 0 2px 0 rgba(0,0,0,0.5);
        }

        .hud-value {
            font-size: 48px;
            color: white;
            text-shadow: 3px 3px 0 #2c3e50, 0 5px 10px rgba(0,0,0,0.5);
            -webkit-text-stroke: 1px #000;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 32px;
            color: #f1c40f;
            text-shadow: 2px 2px 0 #d35400;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(41, 128, 185, 0.95), rgba(44, 62, 80, 0.95));
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            transition: opacity 0.4s, transform 0.4s;
        }

        .hidden { 
            opacity: 0; 
            pointer-events: none; 
            transform: scale(1.1);
        }

        h1 {
            font-size: 90px;
            margin: 0;
            color: #f1c40f;
            text-shadow: 
                0 10px 0 #e67e22, 
                0 20px 0 #d35400,
                0 30px 40px rgba(0,0,0,0.4);
            transform: rotate(-3deg);
            letter-spacing: -2px;
            line-height: 0.8;
            text-align: center;
        }

        .tagline {
            font-size: 24px;
            color: #ecf0f1;
            margin-top: 20px;
            margin-bottom: 50px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 8px 24px;
            border-radius: 50px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            border: none;
            padding: 25px 100px;
            font-size: 40px;
            color: white;
            border-radius: 80px;
            cursor: pointer;
            font-family: 'Titan One', cursive;
            text-transform: uppercase;
            box-shadow: 
                0 10px 0 #1e8449, 
                0 20px 30px rgba(0,0,0,0.4),
                inset 0 2px 0 rgba(255,255,255,0.4);
            transition: transform 0.1s, filter 0.1s;
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover { filter: brightness(1.1); transform: translateY(-2px); }
        .btn:active {
            transform: translateY(10px);
            box-shadow: 0 0 0 #1e8449;
        }

        .btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            20% { left: 100%; }
            100% { left: 100%; }
        }

        input#username {
            background: white;
            border: 5px solid #f1c40f;
            padding: 15px;
            border-radius: 15px;
            font-family: 'Titan One', cursive;
            font-size: 24px;
            text-align: center;
            width: 300px;
            margin-bottom: 30px;
            outline: none;
            color: #2c3e50;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        /* Leaderboard styling */
        .lb-container {
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            margin-bottom: 30px;
            border: 2px solid rgba(255,255,255,0.1);
        }
        .lb-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 20px;
        }
        .lb-rank { color: #f1c40f; margin-right: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="coin-counter">
                <div style="font-size: 40px;">ü™ô</div>
                <span id="coins-display">0</span>
            </div>
            <div class="hud-score-box">
                <div class="hud-label">Score</div>
                <div id="score-display" class="hud-value">0</div>
            </div>
        </div>
    </div>

    <!-- ECRAN ACCUEIL -->
    <div id="start-screen" class="screen">
        <h1>Waajk<br>Surfer</h1>
        <div class="tagline">GOD TIER EDITION</div>
        
        <input type="text" id="username" placeholder="PSEUDO" maxlength="10">
        
        <div class="lb-container" id="leaderboard">
            <!-- Rempli par JS -->
        </div>

        <button class="btn" onclick="startGame()">JOUER</button>
    </div>

    <!-- ECRAN FIN -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #e74c3c;">BOUM !</h1>
        <div style="font-size: 24px; color:#ddd; margin-top:20px;">SCORE FINAL</div>
        <div id="final-score" style="font-size: 80px; color:#f1c40f; margin-bottom: 40px; text-shadow: 0 5px 0 #d35400;">0</div>
        <button class="btn" onclick="resetGame()">REJOUER</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            lanes: [-4.0, 0, 4.0], // Voies plus larges pour sensation de grandeur
            colors: {
                sky: 0x87CEEB,
                ground: 0x2c3e50,
                rails: 0x555555,
                trainRed: 0xc0392b,
                trainGreen: 0x27ae60,
                trainBlue: 0x2980b9,
                coin: 0xFFD700,
                gold: 0xf1c40f
            },
            physics: {
                gravity: 130, // Tr√®s lourd pour sauts secs
                jumpForce: 28, 
                laneSpeed: 24, // D√©placement lat√©ral tr√®s rapide
                fastFall: -70
            },
            speed: { start: 28, max: 50, accel: 0.5 }, // Le jeu acc√©l√®re l√©g√®rement maintenant !
            segmentLength: 40 // Segments plus longs pour moins de pop-in
        };

        const state = {
            isPlaying: false,
            score: 0,
            coins: 0,
            distance: 0,
            speed: CONFIG.speed.start,
            lane: 1,
            playerY: 0,
            velY: 0,
            isJumping: false,
            isRolling: false,
            rollTimer: 0,
            lastSpawnZ: 0,
            currentSurfaceY: 0,
            animTimer: 0,
            cameraShake: 0
        };

        let scene, camera, renderer, clock;
        let playerGroup, playerBody, guard;
        let leftArm, rightArm, leftLeg, rightLeg;
        let activeObjects = [];
        let particles = [];
        
        // Pools pour optimiser la m√©moire
        const pool = { ground: [], coins: [], particles: [] };

        // --- MOTEUR ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            // Brouillard dense pour masquer la g√©n√©ration lointaine et donner du style
            scene.fog = new THREE.Fog(CONFIG.colors.sky, 60, 180);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 7.5, 11);
            camera.lookAt(0, 2, -15);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Ombres douces
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // √âclairage Cin√©matique
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.far = 300;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            scene.add(sun);

            // Lumi√®re de remplissage bleue pour les ombres (ambiance ville)
            const fillLight = new THREE.DirectionalLight(0x2980b9, 0.5);
            fillLight.position.set(-50, 20, -50);
            scene.add(fillLight);

            createPlayer();
            createGuard();
            updateLeaderboardUI();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', handleKey);
            
            let startX, startY;
            document.addEventListener('touchstart', e => { startX = e.touches[0].clientX; startY = e.touches[0].clientY; }, {passive: false});
            document.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - startX;
                const dy = e.changedTouches[0].clientY - startY;
                if(Math.abs(dx) > Math.abs(dy)) {
                    if(Math.abs(dx) > 30) moveLane(dx > 0 ? 1 : -1);
                } else {
                    if(Math.abs(dy) > 30) dy < 0 ? jump() : roll();
                }
            });

            clock = new THREE.Clock();
            animate();
        }

        // --- ASSETS & PERSONNAGE ---
        function createPlayer() {
            playerGroup = new THREE.Group();
            playerBody = new THREE.Group();
            playerBody.position.y = 1.1;

            const matSkin = new THREE.MeshStandardMaterial({color: 0xffdbac});
            const matHoodie = new THREE.MeshStandardMaterial({color: 0xe74c3c});
            const matJeans = new THREE.MeshStandardMaterial({color: 0x34495e});
            const matShoes = new THREE.MeshStandardMaterial({color: 0xffffff});

            // Torse (Hoodie)
            const torse = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.9, 0.45), matHoodie);
            torse.castShadow = true;
            playerBody.add(torse);

            // Sac √† dos
            const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.3), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            backpack.position.set(0, 0.1, 0.35);
            torse.add(backpack);

            // T√™te
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.55, 0.5), matSkin);
            head.position.y = 0.75;
            torse.add(head);

            // Casque Audio
            const headphoneBand = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.05, 8, 20, Math.PI), new THREE.MeshStandardMaterial({color: 0x111111}));
            headphoneBand.rotation.y = Math.PI/2;
            headphoneBand.position.y = 0.3;
            head.add(headphoneBand);
            const earCup = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16), new THREE.MeshStandardMaterial({color: 0xf1c40f}));
            earCup.rotation.z = Math.PI/2;
            earCup.position.set(0.28, 0, 0);
            head.add(earCup);
            const earCup2 = earCup.clone();
            earCup2.position.set(-0.28, 0, 0);
            head.add(earCup2);

            // Casquette √† l'envers
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.15, 0.6), new THREE.MeshStandardMaterial({color: 0x2980b9}));
            cap.position.set(0, 0.3, 0.05);
            cap.rotation.x = 0.1;
            head.add(cap);

            // Bras
            const armGeo = new THREE.BoxGeometry(0.22, 0.7, 0.22);
            leftArm = new THREE.Mesh(armGeo, matHoodie);
            leftArm.position.set(-0.48, 0.1, 0);
            torse.add(leftArm);
            rightArm = new THREE.Mesh(armGeo, matHoodie);
            rightArm.position.set(0.48, 0.1, 0);
            torse.add(rightArm);

            // Jambes
            const legGeo = new THREE.BoxGeometry(0.28, 0.8, 0.28);
            leftLeg = new THREE.Mesh(legGeo, matJeans);
            leftLeg.position.set(-0.2, -0.85, 0);
            torse.add(leftLeg);
            rightLeg = new THREE.Mesh(legGeo, matJeans);
            rightLeg.position.set(0.2, -0.85, 0);
            torse.add(rightLeg);

            // Chaussures
            const shoeGeo = new THREE.BoxGeometry(0.3, 0.2, 0.4);
            const leftShoe = new THREE.Mesh(shoeGeo, matShoes);
            leftShoe.position.set(0, -0.5, 0.1);
            leftLeg.add(leftShoe);
            const rightShoe = leftShoe.clone();
            rightLeg.add(rightShoe);

            playerGroup.add(playerBody);
            scene.add(playerGroup);
        }

        function createGuard() {
            guard = new THREE.Group();
            // Garde plus costaud et mena√ßant
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.3, 2.0, 0.9), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            body.position.y = 1.0;
            guard.add(body);
            // Casquette de police
            const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16), new THREE.MeshStandardMaterial({color: 0x111111}));
            cap.position.y = 2.1;
            guard.add(cap);
            guard.position.z = 6;
            scene.add(guard);
        }

        // --- G√âN√âRATION D'OBSTACLES ---
        function createTrain(isRamp) {
            const g = new THREE.Group();
            const color = isRamp ? CONFIG.colors.trainGreen : (Math.random() > 0.5 ? CONFIG.colors.trainRed : CONFIG.colors.trainBlue);
            
            // Corps principal
            const body = new THREE.Mesh(new THREE.BoxGeometry(3.2, 3.8, 14), new THREE.MeshStandardMaterial({color, roughness: 0.2, metalness: 0.1}));
            body.position.y = 1.9;
            body.castShadow = true;
            g.add(body);

            // Toit d√©taill√©
            const roof = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.2, 13.8), new THREE.MeshStandardMaterial({color: 0x555555}));
            roof.position.y = 3.9;
            g.add(roof);

            // Phares
            const lightGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const lightMat = new THREE.MeshStandardMaterial({color: 0xffffff, emissive: 0xffffcc, emissiveIntensity: 0.5});
            const l1 = new THREE.Mesh(lightGeo, lightMat);
            l1.rotation.x = Math.PI/2;
            l1.position.set(-0.8, 1.5, 7.1);
            g.add(l1);
            const l2 = l1.clone();
            l2.position.set(0.8, 1.5, 7.1);
            g.add(l2);

            // Roues
            const wheelMat = new THREE.MeshStandardMaterial({color: 0x111111});
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 3.3, 16);
            wheelGeo.rotateZ(Math.PI/2);
            for(let z of [-4, 4]) {
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.position.set(0, 0.5, z);
                g.add(w);
            }

            // Rampe
            if(isRamp) {
                const ramp = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.2, 7), new THREE.MeshStandardMaterial({color}));
                ramp.position.set(0, 1.8, 9.5); // Ajust√© pour coller au train
                ramp.rotation.x = 0.52; // Pente douce
                g.add(ramp);
            }

            g.userData = { type: 'obstacle', subtype: 'train', isRamp, h: 4.0 }; // Hauteur un peu plus g√©n√©reuse pour hitbox
            return g;
        }

        function createBarrier() {
            const g = new THREE.Group();
            // Barri√®re style chantier
            const bar = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.0, 0.3), new THREE.MeshStandardMaterial({color: 0xf1c40f}));
            bar.position.y = 1.3;
            bar.castShadow = true;
            g.add(bar);
            
            // Rayures
            const stripeMat = new THREE.MeshBasicMaterial({color: 0x111111});
            for(let i=0; i<4; i++) {
                const s = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.05, 0.32), stripeMat);
                s.position.set(-1.2 + i*0.8, 1.3, 0);
                g.add(s);
            }

            // Pieds
            const legGeo = new THREE.BoxGeometry(0.4, 1.8, 0.4);
            const legMat = new THREE.MeshStandardMaterial({color: 0x95a5a6});
            const l1 = new THREE.Mesh(legGeo, legMat);
            l1.position.set(-1.5, 0.9, 0); g.add(l1);
            const l2 = l1.clone(); l2.position.x = 1.5; g.add(l2);
            
            g.userData = { type: 'obstacle', subtype: 'barrier', h: 1.8 };
            return g;
        }

        function createParticle(x, y, z) {
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({color: 0xffd700});
            const p = new THREE.Mesh(geo, mat);
            p.position.set(x, y, z);
            p.userData = { 
                vel: new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10, (Math.random()-0.5)*10), 
                life: 1.0 
            };
            scene.add(p);
            particles.push(p);
        }

        // --- G√âN√âRATION DE PATTERNS ---
        function spawnSegment(z) {
            // Sol (Route + Trottoirs int√©gr√©s visuellement)
            const floorW = 18;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorW, 40.5), new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.8}));
            floor.rotation.x = -Math.PI/2;
            floor.position.z = z;
            floor.receiveShadow = true;
            scene.add(floor);
            activeObjects.push(floor);

            // Rails
            CONFIG.lanes.forEach(x => {
                const rails = new THREE.Group();
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 40), new THREE.MeshStandardMaterial({color: 0x888888}));
                r1.position.set(x-1.0, 0.1, z);
                rails.add(r1);
                const r2 = r1.clone();
                r2.position.set(x+1.0, 0.1, z);
                rails.add(r2);
                
                // Traverses
                for(let k=0; k<15; k++) {
                    const sleeper = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 0.6), new THREE.MeshStandardMaterial({color: 0x5d4037}));
                    sleeper.position.set(x, 0.05, z - 20 + k*2.6);
                    rails.add(sleeper);
                }
                scene.add(rails);
                activeObjects.push(rails);
            });

            // Environnement Lat√©ral (B√¢timents style cartoon)
            if(Math.random() > 0.3) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const h = 15 + Math.random() * 20;
                const build = new THREE.Mesh(new THREE.BoxGeometry(10, h, 15), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL(Math.random(), 0.6, 0.4)}));
                build.position.set(side * 22, h/2, z);
                scene.add(build);
                activeObjects.push(build);
            }

            if(z > -40) return; // Zone de d√©part vide

            // PATTERNS DE JEU (Logique intelligente)
            const patternType = Math.floor(Math.random() * 4); // 0: Random, 1: 3 trains, 2: Barri√®re saut, 3: Pi√®ces
            
            const lanes = [0, 1, 2].sort(() => Math.random() - 0.5);

            if(patternType === 1) { // Mur de trains avec une rampe
                const rampLane = lanes[0];
                for(let i=0; i<3; i++) {
                    const x = CONFIG.lanes[i];
                    const isRamp = (i === rampLane);
                    const train = createTrain(isRamp);
                    train.position.set(x, 0, z);
                    scene.add(train);
                    activeObjects.push(train);
                    
                    if(isRamp) { // Pi√®ces sur le train rampe
                        addCoins(x, 5.0, z, 5);
                    }
                }
            } 
            else if (patternType === 2) { // Barri√®res align√©es
                for(let i=0; i<3; i++) {
                    if(Math.random() > 0.3) {
                        const b = createBarrier();
                        b.position.set(CONFIG.lanes[i], 0, z);
                        scene.add(b);
                        activeObjects.push(b);
                    } else {
                         addCoins(CONFIG.lanes[i], 1.5, z, 3);
                    }
                }
            }
            else { // Random classique mais √©quilibr√©
                for(let i=0; i<2; i++) { // Max 2 obstacles pour laisser une voie
                    const lane = lanes[i];
                    const x = CONFIG.lanes[lane];
                    let obj;
                    
                    if(Math.random() < 0.6) {
                        obj = createTrain(Math.random() > 0.7);
                        // Pi√®ces sur le toit
                        if(Math.random() > 0.5) addCoins(x, 5.0, z, 4);
                    } else {
                        obj = createBarrier();
                        // Pi√®ce SOUS la barri√®re ou au dessus
                        if(Math.random() > 0.5) {
                            addCoins(x, 1.5, z, 1); // Juste une pi√®ce pour inciter √† sauter
                        }
                    }
                    obj.position.set(x, 0, z);
                    scene.add(obj);
                    activeObjects.push(obj);
                }
                // Voie libre = pi√®ces
                addCoins(CONFIG.lanes[lanes[2]], 1.5, z, 5);
            }
        }

        function addCoins(x, y, z, count) {
            for(let k=0; k<count; k++) {
                const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16), new THREE.MeshStandardMaterial({color: 0xFFD700, metalness: 0.9, roughness: 0.1}));
                coin.rotation.x = Math.PI/2;
                coin.position.set(x, y, z - (count*2) + k*4);
                coin.userData = { type: 'coin' };
                scene.add(coin);
                activeObjects.push(coin);
            }
        }

        // --- GAME LOOP ---
        function update(dt) {
            if(!state.isPlaying) return;

            // Acc√©l√©ration progressive
            if(state.speed < CONFIG.speed.max) {
                state.speed += CONFIG.speed.accel * dt;
            }

            const step = state.speed * dt;
            state.distance += step;
            state.score = Math.floor(state.distance * 2); // Score x2 pour le fun
            document.getElementById('score-display').innerText = state.score;

            state.lastSpawnZ += step;
            while(state.lastSpawnZ > -240) {
                spawnSegment(state.lastSpawnZ);
                state.lastSpawnZ -= CONFIG.segmentLength;
            }

            let foundSurfaceY = 0;

            // Gestion Objets
            for(let i=activeObjects.length-1; i>=0; i--) {
                const obj = activeObjects[i];
                obj.position.z += step;

                if(obj.userData.type === 'coin') {
                    obj.rotation.y += 5 * dt;
                    obj.rotation.z = Math.sin(Date.now()*0.005) * 0.2; // Petit flottement

                    // Effet Magn√©tique
                    const dx = playerGroup.position.x - obj.position.x;
                    const dz = 0 - obj.position.z; // Player est √† z=0
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    
                    if(dist < 4.0) { // Attraction
                         obj.position.x += dx * 5 * dt;
                         obj.position.z += dz * 5 * dt;
                    }

                    if(dist < 1.5) {
                        state.coins++;
                        document.getElementById('coins-display').innerText = state.coins;
                        // Spawn particules
                        for(let p=0; p<5; p++) createParticle(obj.position.x, obj.position.y, obj.position.z);
                        scene.remove(obj);
                        activeObjects.splice(i, 1);
                        continue;
                    }
                }

                if(obj.userData.type === 'obstacle') {
                    const col = checkCollision(obj);
                    if(col) {
                        if(col.type === 'surface' || col.type === 'ramp') {
                            foundSurfaceY = Math.max(foundSurfaceY, col.y);
                            if(col.type === 'ramp') state.playerY = col.y; // Monter la rampe
                        } else {
                            gameOver();
                        }
                    }
                }

                if(obj.position.z > 50) {
                    scene.remove(obj);
                    activeObjects.splice(i, 1);
                }
            }

            // Gestion Particules
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.position.addScaledVector(p.userData.vel, dt);
                p.userData.life -= dt * 2;
                p.scale.setScalar(p.userData.life);
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            state.currentSurfaceY = foundSurfaceY;

            // Physique Player
            const targetX = CONFIG.lanes[state.lane];
            const moveX = (targetX - playerGroup.position.x) * CONFIG.physics.laneSpeed * dt;
            playerGroup.position.x += moveX;
            // Inclinaison (Banking)
            playerBody.rotation.z = -moveX * 0.15;

            // Animation course proc√©durale
            state.animTimer += dt * (state.speed * 0.8);
            if(!state.isJumping && !state.isRolling) {
                const runY = Math.abs(Math.sin(state.animTimer)) * 0.15;
                playerBody.position.y = 1.1 + runY;
                
                const limbAmp = 0.8;
                leftLeg.rotation.x = Math.sin(state.animTimer) * limbAmp;
                rightLeg.rotation.x = Math.sin(state.animTimer + Math.PI) * limbAmp;
                leftArm.rotation.x = Math.sin(state.animTimer + Math.PI) * limbAmp;
                rightArm.rotation.x = Math.sin(state.animTimer) * limbAmp;
            } else {
                // Reset pose en l'air
                leftLeg.rotation.x = 0.2; rightLeg.rotation.x = -0.2;
                leftArm.rotation.x = -0.5; rightArm.rotation.x = -0.5;
            }

            // Saut & Gravit√©
            if(state.isJumping) {
                state.playerY += state.velY * dt;
                state.velY -= CONFIG.physics.gravity * dt;
                
                if(state.velY < 0 && state.playerY <= state.currentSurfaceY) {
                    state.playerY = state.currentSurfaceY;
                    state.isJumping = false;
                    playerBody.position.y = 1.1;
                    // Impact shake
                    state.cameraShake = 0.3;
                }
            } else {
                if(state.playerY > state.currentSurfaceY + 0.2) {
                    state.isJumping = true; 
                    state.velY = 0;
                } else {
                    state.playerY = state.currentSurfaceY;
                }
            }

            // Roulade
            if(state.isRolling) {
                state.rollTimer -= dt;
                const p = 1.0 - (state.rollTimer / 0.5);
                playerBody.rotation.x = -Math.PI * 2 * p;
                playerBody.position.y = 0.6; // Hitbox visuelle r√©duite
                if(state.rollTimer <= 0) {
                    state.isRolling = false;
                    playerBody.rotation.x = 0;
                    playerBody.position.y = 1.1;
                }
            }

            playerGroup.position.y = state.playerY;

            // Camera Follow & Shake
            camera.position.x += (playerGroup.position.x * 0.4 - camera.position.x) * 5 * dt;
            if(state.cameraShake > 0) {
                camera.position.y = 7.5 + (Math.random()-0.5) * state.cameraShake;
                state.cameraShake -= dt;
            } else {
                camera.position.y += (7.5 - camera.position.y) * 2 * dt;
            }
            
            // Le garde suit
            guard.position.x += (playerGroup.position.x - guard.position.x) * 8 * dt;
        }

        function checkCollision(obj) {
            const pBounds = {
                x: playerGroup.position.x,
                y: state.playerY + 1.1,
                z: 0,
                w: 0.6, h: 1.4 // Hitbox Player
            };

            const dx = Math.abs(pBounds.x - obj.position.x);
            const dz = Math.abs(obj.position.z); // Player est √† 0
            
            // Train
            if(obj.userData.subtype === 'train') {
                // Rampe logic
                if(obj.userData.isRamp) {
                    const distToFront = (obj.position.z + 7) - 0;
                    if(distToFront > 0 && distToFront < 7 && dx < 1.6) {
                        return { type: 'ramp', y: (distToFront/7) * 3.9 };
                    }
                }
                // Sur le toit
                if(state.playerY > 3.0 && dz < 6.5 && dx < 1.6) return { type: 'surface', y: 3.9 };
                // Crash
                if(dz < 6.0 && dx < 1.4) return { type: 'hit' };
            }

            // Barri√®re
            if(obj.userData.subtype === 'barrier') {
                if(state.playerY > 1.4 && dz < 1.0 && dx < 1.7) return { type: 'surface', y: 1.7 };
                if(dz < 0.6 && dx < 1.7) return { type: 'hit' };
            }

            return null;
        }

        // --- INPUTS ---
        function handleKey(e) {
            if(!state.isPlaying) return;
            if(e.key === 'ArrowLeft' || e.key === 'q') moveLane(-1);
            if(e.key === 'ArrowRight' || e.key === 'd') moveLane(1);
            if(e.key === 'ArrowUp' || e.key === 'z') jump();
            if(e.key === 'ArrowDown' || e.key === 's') roll();
        }

        function moveLane(dir) {
            state.lane = Math.max(0, Math.min(2, state.lane + dir));
        }

        function jump() {
            if(!state.isJumping && !state.isRolling) {
                state.isJumping = true; state.velY = CONFIG.physics.jumpForce;
            }
        }

        function roll() {
            if(state.isJumping) { state.isJumping = false; state.velY = CONFIG.physics.fastFall; }
            if(!state.isRolling) { state.isRolling = true; state.rollTimer = 0.5; }
        }

        function startGame() {
            const name = document.getElementById('username').value.trim() || "SURFER";
            // Animation UI
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // Reset complet
            activeObjects.forEach(o => scene.remove(o));
            activeObjects = [];
            particles.forEach(p => scene.remove(p));
            particles = [];
            
            state.score = 0; state.coins = 0; state.distance = 0; state.speed = CONFIG.speed.start;
            state.isPlaying = true; state.lane = 1; state.lastSpawnZ = 0; state.playerY = 0;
            playerGroup.position.set(0,0,0);
            
            // Pr√©g√©n√©ration
            while(state.lastSpawnZ > -240) { spawnSegment(state.lastSpawnZ); state.lastSpawnZ -= CONFIG.segmentLength; }
        }

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            
            // Save score logic (simplified)
            let scores = JSON.parse(localStorage.getItem('waajkGodScores') || "[]");
            scores.push({name: document.getElementById('username').value || "Moi", score: state.score});
            scores.sort((a,b) => b.score - a.score);
            localStorage.setItem('waajkGodScores', JSON.stringify(scores.slice(0,5)));
            updateLeaderboardUI();
        }

        function resetGame() { startGame(); }

        function updateLeaderboardUI() {
            const scores = JSON.parse(localStorage.getItem('waajkGodScores') || "[]");
            const div = document.getElementById('leaderboard');
            if(scores.length === 0) div.innerHTML = "<div style='text-align:center; color:#ccc'>Sois le premier !</div>";
            else div.innerHTML = "<div style='text-align:center; color:#FFD700; margin-bottom:10px;'>TOP 5</div>" + 
                scores.map((s, i) => `<div class='lb-item'><span class='lb-rank'>#${i+1}</span><span>${s.name}</span><span>${s.score}</span></div>`).join('');
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            update(dt);
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
