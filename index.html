<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Subway Surfer 3D - ULTIMATE WORLD</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            text-shadow: 2px 2px 0 #000;
        }

        .hud-stat {
            font-family: 'Verdana', sans-serif;
            font-weight: 900;
            font-size: 36px;
            color: white;
            -webkit-text-stroke: 1px black;
        }

        #coins-display { color: #FFD700; }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 20;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-family: 'Arial Black', sans-serif;
            font-size: 50px;
            margin-bottom: 10px;
            text-transform: uppercase;
            color: #FFD700;
            text-shadow: 0 5px 0 #e67e22;
            transform: skew(-5deg) rotate(-2deg);
            text-align: center;
        }

        input#username {
            padding: 15px;
            border-radius: 30px;
            border: none;
            font-size: 20px;
            text-align: center;
            margin-bottom: 20px;
            width: 250px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            font-weight: bold;
            text-transform: uppercase;
        }

        .btn {
            background: #2ecc71;
            border: none;
            padding: 20px 80px;
            font-size: 28px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 8px 0 #27ae60, 0 15px 20px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 3px 0 #27ae60;
        }

        .leaderboard-box {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 15px;
            width: 80%;
            max-width: 350px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .lb-row {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-family: monospace;
            font-size: 16px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display" class="hud-stat">0</div>
            <div id="coins-display" class="hud-stat">0</div>
        </div>
    </div>

    <!-- ECRAN ACCUEIL -->
    <div id="start-screen" class="screen">
        <h1>Subway<br>World</h1>
        <p style="font-size: 18px; margin-bottom: 20px; opacity: 0.8;">Échappe au Garde !</p>
        
        <input type="text" id="username" placeholder="PSEUDO (Optionnel)" maxlength="10">
        
        <div class="leaderboard-box">
            <div style="text-align:center; font-weight:bold; margin-bottom:10px; color:#FFD700;">TOP JOUEURS</div>
            <div id="lb-content">Chargement...</div>
        </div>

        <button class="btn" onclick="startGame()">JOUER</button>
    </div>

    <!-- ECRAN FIN -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 5px 0 #c0392b;">PERDU !</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">Score: <span id="final-score" style="font-weight:bold; color:#FFD700;">0</span></div>
        <button class="btn" onclick="resetGame()">REJOUER</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            lanes: [-3.5, 0, 3.5], 
            colors: {
                sky: 0x87CEEB,
                ground: 0x554433,
                grass: 0x7cfc00,
                rails: 0x888888,
                wood: 0x5d4037,
                building: [0xe74c3c, 0xf1c40f, 0x3498db, 0x9b59b6, 0x1abc9c] // Couleurs variées
            },
            // VITESSE RALENTIE ICI
            speed: { start: 15, max: 60, accel: 0.6 },
            physics: { gravity: 75, jumpForce: 18, laneSpeed: 18 }
        };

        // --- ETAT ---
        const state = {
            isPlaying: false,
            score: 0,
            coins: 0,
            distance: 0,
            speed: CONFIG.speed.start,
            lane: 1,
            targetX: 0,
            playerY: 0,
            velY: 0,
            isJumping: false,
            isRolling: false,
            rollTimer: 0,
            username: 'Joueur'
        };

        // --- MOTEUR ---
        let scene, camera, renderer, clock;
        let player, playerMesh, guard;
        let activeObjects = [];
        // Pools pour optimiser la mémoire
        const pool = { 
            ground: [], 
            trains: [], 
            barriers: [], 
            coins: [], 
            catenary: [],
            buildings: [], // Nouveau pool décor
            trees: []      // Nouveau pool décor
        }; 

        // LEADERBOARD
        let leaderboards = JSON.parse(localStorage.getItem('subwayRealScores')) || [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            scene.fog = new THREE.Fog(CONFIG.colors.sky, 40, 150);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 300);
            camera.position.set(0, 6, 9);
            camera.lookAt(0, 1, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Lumières
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(50, 80, 30);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.far = 150;
            sun.shadow.camera.left = -30;
            sun.shadow.camera.right = 30;
            sun.shadow.camera.top = 30;
            sun.shadow.camera.bottom = -10;
            scene.add(sun);

            createPlayer();
            createGuard();
            prewarmPools();
            spawnInitialWorld();
            updateLeaderboardUI();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', handleKey);
            
            let tsX, tsY;
            document.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; tsY = e.touches[0].clientY; }, {passive: false});
            document.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
            document.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - tsX;
                const dy = e.changedTouches[0].clientY - tsY;
                if(Math.abs(dx) > Math.abs(dy)) {
                    if(Math.abs(dx) > 30) changeLane(dx > 0 ? 1 : -1);
                } else {
                    if(Math.abs(dy) > 30) dy < 0 ? jump() : roll();
                }
            }, {passive: false});

            animate();
        }

        // --- PERSONNAGES ---
        function createPlayer() {
            player = new THREE.Group();
            
            // Garçon stylisé
            const geo = new THREE.BoxGeometry(0.8, 1.5, 0.6);
            const mat = new THREE.MeshStandardMaterial({ color: 0x3498db }); 
            playerMesh = new THREE.Mesh(geo, mat);
            playerMesh.position.y = 0.75;
            playerMesh.castShadow = true;
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({color: 0xffccaa}));
            head.position.y = 1.1;
            playerMesh.add(head);

            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.62, 0.2, 0.7), new THREE.MeshStandardMaterial({color: 0xe74c3c}));
            cap.position.set(0, 0.3, 0.1);
            head.add(cap);

            // Sac à dos spray
            const pack = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.3), new THREE.MeshStandardMaterial({color: 0x333333}));
            pack.position.set(0, 0.2, -0.4);
            playerMesh.add(pack);

            player.add(playerMesh);
            scene.add(player);
        }

        function createGuard() {
            guard = new THREE.Group();
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.7, 0.8), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            body.position.y = 0.85;
            body.castShadow = true;
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 0.55), new THREE.MeshStandardMaterial({color: 0xffccaa}));
            head.position.y = 1.25;
            body.add(head);

            const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.2), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            hat.position.y = 0.4;
            head.add(hat);

            // Bedaine
            const belly = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 0.4), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            belly.position.set(0, 0, 0.4);
            body.add(belly);

            guard.add(body);
            guard.position.set(0, 0, 4.5); 
            scene.add(guard);
        }

        // --- POOLING & ASSETS ---
        function prewarmPools() {
            // Helper pour ajouter à la scène directement
            const createAndAdd = (creator) => {
                const obj = creator();
                obj.visible = false;
                scene.add(obj);
                return obj;
            };

            for(let i=0; i<30; i++) pool.ground.push(createAndAdd(createGroundMesh));
            for(let i=0; i<15; i++) pool.trains.push(createAndAdd(createTrainMesh));
            for(let i=0; i<25; i++) pool.barriers.push(createAndAdd(createBarrierMesh));
            for(let i=0; i<60; i++) pool.coins.push(createAndAdd(createCoinMesh));
            for(let i=0; i<20; i++) pool.catenary.push(createAndAdd(createCatenaryMesh));
            for(let i=0; i<40; i++) pool.buildings.push(createAndAdd(createBuildingMesh));
            for(let i=0; i<40; i++) pool.trees.push(createAndAdd(createTreeMesh));
        }

        function createGroundMesh() {
            const group = new THREE.Group();
            
            // Sol Gravier
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(12, 20), new THREE.MeshStandardMaterial({color: CONFIG.colors.ground, roughness: 1}));
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            group.add(floor);

            // Quais sur les côtés (Trottoirs)
            const sidewalkGeo = new THREE.BoxGeometry(8, 1, 20);
            const sidewalkMat = new THREE.MeshStandardMaterial({color: 0x95a5a6});
            const sideL = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sideL.position.set(-10, 0.5, 0); // Gauche
            sideL.receiveShadow = true;
            group.add(sideL);
            const sideR = sideL.clone();
            sideR.position.set(10, 0.5, 0); // Droite
            group.add(sideR);

            // Rails x3
            CONFIG.lanes.forEach(x => {
                // Ballast
                const ballast = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 20), new THREE.MeshStandardMaterial({color: 0x3e2723}));
                ballast.position.set(x, 0.05, 0);
                group.add(ballast);

                // Fer
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 20), new THREE.MeshStandardMaterial({color: 0xbdc3c7, metalness: 0.6}));
                r1.position.set(x-0.8, 0.15, 0);
                group.add(r1);
                const r2 = r1.clone();
                r2.position.set(x+0.8, 0.15, 0);
                group.add(r2);

                // Traverses
                for(let k=0; k<10; k++) {
                    const sleeper = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.12, 0.4), new THREE.MeshStandardMaterial({color: CONFIG.colors.wood}));
                    sleeper.position.set(x, 0.1, -9 + k*2);
                    group.add(sleeper);
                }
            });

            return group;
        }

        function createBuildingMesh() {
            // Immeuble simple avec fenêtres
            const h = 8 + Math.random() * 8;
            const group = new THREE.Group();
            
            const color = CONFIG.colors.building[Math.floor(Math.random()*CONFIG.colors.building.length)];
            const body = new THREE.Mesh(new THREE.BoxGeometry(5, h, 5), new THREE.MeshStandardMaterial({color: color}));
            body.position.y = h/2;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            // Fenêtres
            const winMat = new THREE.MeshStandardMaterial({color: 0xecf0f1});
            for(let y=2; y<h-1; y+=2) {
                const w = new THREE.Mesh(new THREE.BoxGeometry(5.1, 1, 3), winMat);
                w.position.y = y;
                group.add(w);
            }

            return group;
        }

        function createTreeMesh() {
            const group = new THREE.Group();
            
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 2), new THREE.MeshStandardMaterial({color: 0x795548}));
            trunk.position.y = 1;
            trunk.castShadow = true;
            group.add(trunk);

            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(2), new THREE.MeshStandardMaterial({color: 0x27ae60}));
            leaves.position.y = 3;
            leaves.castShadow = true;
            group.add(leaves);

            return group;
        }

        function createCatenaryMesh() {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: 0x34495e}); // Gris foncé métal
            
            // Poteaux en H
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.6, 9, 0.6), mat);
            p1.position.set(-6.5, 4.5, 0);
            p1.castShadow = true;
            group.add(p1);
            const p2 = p1.clone();
            p2.position.set(6.5, 4.5, 0);
            group.add(p2);

            // Poutre transversale
            const beam = new THREE.Mesh(new THREE.BoxGeometry(14, 0.5, 0.5), mat);
            beam.position.set(0, 8, 0);
            group.add(beam);

            // Fils
            const wireGeo = new THREE.CylinderGeometry(0.03, 0.03, 20);
            wireGeo.rotateX(Math.PI/2);
            const wireMat = new THREE.MeshBasicMaterial({color: 0x222222});
            
            CONFIG.lanes.forEach(x => {
                const w = new THREE.Mesh(wireGeo, wireMat);
                w.position.set(x, 7, 0);
                group.add(w);
                // Support vertical fil
                const sup = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.1), mat);
                sup.position.set(x, 7.5, 0);
                group.add(sup);
            });

            return group;
        }

        function createTrainMesh() {
            const group = new THREE.Group();
            
            const bodyGeo = new THREE.CylinderGeometry(1.45, 1.45, 11, 16);
            bodyGeo.rotateX(Math.PI/2);
            const bodyMat = new THREE.MeshStandardMaterial({color: 0xe74c3c, roughness: 0.2}); 
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 2.1; 
            body.castShadow = true;
            group.add(body);

            // Base
            const base = new THREE.Mesh(new THREE.BoxGeometry(2.9, 1.2, 11), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            base.position.y = 0.6;
            group.add(base);

            // Fenêtres
            const winMat = new THREE.MeshStandardMaterial({color: 0x34495e});
            const wins = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.8, 9), winMat);
            wins.position.y = 2.3;
            group.add(wins);

            // Logo frontal
            const logo = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.2), new THREE.MeshBasicMaterial({color: 0xf1c40f}));
            logo.rotateX(Math.PI/2);
            logo.position.set(0, 2, 5.5);
            group.add(logo);

            // Phares
            const light = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
            light.rotateX(Math.PI/2);
            light.position.set(-1, 1, 5.5);
            group.add(light);
            const l2 = light.clone();
            l2.position.set(1, 1, 5.5);
            group.add(l2);

            group.userData = {type: 'obstacle', hit: {w:2.6, h:3.5, d:11}};
            return group;
        }

        function createBarrierMesh() {
            const group = new THREE.Group();
            const bar = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.9, 0.2), new THREE.MeshStandardMaterial({color: 0xe67e22}));
            bar.position.y = 1.1;
            bar.castShadow = true;
            group.add(bar);

            const leg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1.3, 0.25), new THREE.MeshStandardMaterial({color: 0x7f8c8d}));
            leg.position.set(-1.2, 0.65, 0);
            group.add(leg);
            const leg2 = leg.clone();
            leg2.position.set(1.2, 0.65, 0);
            group.add(leg2);

            group.userData = {type: 'obstacle', hit: {w:2.6, h:1.0, d:0.5}};
            return group;
        }

        function createCoinMesh() {
            const m = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.1, 24), new THREE.MeshBasicMaterial({color: 0xFFD700}));
            m.rotation.x = Math.PI/2;
            m.rotation.z = Math.PI/2;
            m.userData = {type: 'coin'};
            return m;
        }

        // --- SPAWN LOGIC ---
        function getFromPool(arr) {
            const obj = arr.find(o => !o.visible);
            if(obj) {
                obj.visible = true;
                return obj;
            }
            return null;
        }

        function spawnInitialWorld() {
            for(let i=0; i<12; i++) spawnSegment(-i * 20);
        }

        function spawnSegment(z) {
            // Sol
            const g = getFromPool(pool.ground);
            if(g) { g.position.set(0, 0, z); activeObjects.push(g); }

            // Caténaire (1/2)
            if(Math.random() > 0.3) {
                const c = getFromPool(pool.catenary);
                if(c) { c.position.set(0, 0, z); activeObjects.push(c); }
            }

            // DÉCOR VILLE (Sur les côtés)
            // Gauche
            const sceneryL = (Math.random() > 0.5) ? getFromPool(pool.buildings) : getFromPool(pool.trees);
            if(sceneryL) {
                sceneryL.position.set(-11 - Math.random()*2, 0, z);
                sceneryL.rotation.y = (Math.random() > 0.5 ? 0 : Math.PI/2);
                activeObjects.push(sceneryL);
            }
            // Droite
            const sceneryR = (Math.random() > 0.5) ? getFromPool(pool.buildings) : getFromPool(pool.trees);
            if(sceneryR) {
                sceneryR.position.set(11 + Math.random()*2, 0, z);
                sceneryR.rotation.y = (Math.random() > 0.5 ? 0 : Math.PI/2);
                activeObjects.push(sceneryR);
            }

            // OBSTACLES (Après le départ)
            if(z > -40) return;

            const freeLane = Math.floor(Math.random() * 3);
            
            for(let i=0; i<3; i++) {
                // Voie libre = Pièces
                if(i === freeLane) {
                    if(Math.random() > 0.3) {
                        for(let k=0; k<4; k++) {
                            const coin = getFromPool(pool.coins);
                            if(coin) {
                                coin.position.set(CONFIG.lanes[i], 1.2, z - 2 - k*4);
                                activeObjects.push(coin);
                            }
                        }
                    }
                    continue;
                }

                // Obstacles
                const x = CONFIG.lanes[i];
                const r = Math.random();
                
                if(r < 0.45) { // Train
                    const t = getFromPool(pool.trains);
                    if(t) {
                        t.position.set(x, 0, z - 10);
                        t.userData.speed = (Math.random() < 0.35) ? 25 : 0; // 35% trains bougent
                        activeObjects.push(t);
                    }
                } else if(r < 0.85) { // Barrière
                    const b = getFromPool(pool.barriers);
                    if(b) {
                        b.position.set(x, 0, z - 10);
                        activeObjects.push(b);
                    }
                }
            }
        }

        // --- UPDATE LOOP ---
        let spawnTimer = 0;

        function update(dt) {
            if(state.speed < CONFIG.speed.max) state.speed += CONFIG.speed.accel * dt;
            
            const dist = state.speed * dt;
            state.distance += dist;
            state.score = Math.floor(state.distance);
            document.getElementById('score-display').innerText = state.score;

            spawnTimer += dist;
            if(spawnTimer > 20) {
                spawnSegment(-100);
                spawnTimer = 0;
            }

            for(let i = activeObjects.length - 1; i >= 0; i--) {
                const obj = activeObjects[i];
                if(!obj.visible) continue;

                let zSpeed = dist;
                if(obj.userData.speed) zSpeed += obj.userData.speed * dt; 

                obj.position.z += zSpeed;

                if(obj.userData.type === 'coin') obj.rotation.y += 4 * dt;

                if(checkCollision(obj)) {
                    if(obj.userData.type === 'coin') {
                        state.coins++;
                        document.getElementById('coins-display').innerText = state.coins;
                        obj.visible = false;
                    } else if(obj.userData.type === 'obstacle') {
                        gameOver();
                    }
                }

                if(obj.position.z > 20) obj.visible = false;
            }

            // Player
            state.targetX = CONFIG.lanes[state.lane];
            player.position.x += (state.targetX - player.position.x) * CONFIG.physics.laneSpeed * dt;
            player.rotation.y = (state.targetX - player.position.x) * -0.05;
            player.rotation.z = (state.targetX - player.position.x) * 0.05; // Lean

            if(state.isJumping) {
                state.playerY += state.velY * dt;
                state.velY -= CONFIG.physics.gravity * dt;
                if(state.playerY <= 0) {
                    state.playerY = 0;
                    state.isJumping = false;
                    playerMesh.position.y = 0.75;
                }
            } else if (state.isRolling) {
                state.rollTimer -= dt;
                playerMesh.scale.y = 0.5;
                playerMesh.position.y = 0.4;
                if(state.rollTimer <= 0) {
                    state.isRolling = false;
                    playerMesh.scale.y = 1;
                    playerMesh.position.y = 0.75;
                }
            }
            player.position.y = state.playerY;

            // Garde : Il est proche au début puis recule, revient si on trébuche (simulé)
            let guardTargetZ = 3;
            // Si on saute ou roule, il se rapproche un peu pour le stress
            if(state.isJumping || state.isRolling) guardTargetZ = 2.5;
            
            guard.position.x += (player.position.x - guard.position.x) * 3 * dt;
            guard.position.z += (guardTargetZ - guard.position.z) * 2 * dt;
            guard.position.y = 0;

            // Anim course
            if(!state.isJumping && !state.isRolling) {
                playerMesh.position.y = 0.75 + Math.sin(Date.now() * 0.018) * 0.08;
                // Garde court aussi
                guard.position.y = Math.abs(Math.sin(Date.now() * 0.018 + 0.5)) * 0.1;
            }
        }

        function checkCollision(obj) {
            if(!obj.visible) return false;
            
            const pBox = new THREE.Box3().setFromObject(playerMesh);
            pBox.expandByScalar(-0.3); 
            const oBox = new THREE.Box3().setFromObject(obj);
            oBox.expandByScalar(-0.25);

            return pBox.intersectsBox(oBox);
        }

        // --- CONTROLES ---
        function handleKey(e) {
            if(!state.isPlaying) return;
            if(e.key === 'ArrowLeft' || e.key === 'q') changeLane(-1);
            if(e.key === 'ArrowRight' || e.key === 'd') changeLane(1);
            if(e.key === 'ArrowUp' || e.key === 'z') jump();
            if(e.key === 'ArrowDown' || e.key === 's') roll();
        }

        function changeLane(dir) {
            const next = state.lane + dir;
            if(next >= 0 && next <= 2) state.lane = next;
        }

        function jump() {
            if(!state.isJumping) {
                state.isJumping = true;
                state.velY = CONFIG.physics.jumpForce;
                state.isRolling = false;
            }
        }

        function roll() {
            if(!state.isRolling && !state.isJumping) {
                state.isRolling = true;
                state.rollTimer = 0.7;
                state.velY = -15; 
            }
        }

        // --- UI & SYSTEM ---
        function startGame() {
            const inputName = document.getElementById('username').value.trim();
            state.username = inputName || "Joueur";

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            activeObjects.forEach(o => o.visible = false);
            spawnInitialWorld();
            
            state.score = 0;
            state.coins = 0;
            state.distance = 0;
            state.speed = CONFIG.speed.start;
            state.isPlaying = true;
            state.lane = 1;
            state.targetX = 0;
            player.position.set(0,0,0);
        }

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            saveScore(state.username, state.score);
            updateLeaderboardUI();
        }

        function resetGame() {
            startGame();
        }

        function saveScore(name, score) {
            const existing = leaderboards.find(l => l.name === name);
            if(existing) {
                if(score > existing.score) existing.score = score;
            } else {
                leaderboards.push({name, score});
            }
            leaderboards.sort((a,b) => b.score - a.score);
            leaderboards = leaderboards.slice(0, 10);
            localStorage.setItem('subwayRealScores', JSON.stringify(leaderboards));
        }

        function updateLeaderboardUI() {
            const div = document.getElementById('lb-content');
            if(leaderboards.length === 0) {
                div.innerHTML = "<div style='text-align:center; color:#ddd; font-style:italic;'>Aucun score...</div>";
                return;
            }
            div.innerHTML = leaderboards.map((l, i) => `
                <div class="lb-row">
                    <span>${i+1}. ${l.name}</span>
                    <span style="color:#FFD700">${l.score}</span>
                </div>
            `).join('');
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            if(state.isPlaying) update(dt);
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
