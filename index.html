<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>waajk Surfer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            text-shadow: 2px 2px 0 #000;
        }

        .hud-stat {
            font-family: 'Verdana', sans-serif;
            font-weight: 900;
            font-size: 32px;
            color: white;
            -webkit-text-stroke: 1.5px black;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #coins-display { color: #FFD700; }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 20;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-family: 'Arial Black', sans-serif;
            font-size: 52px;
            margin-bottom: 5px;
            text-transform: uppercase;
            color: #FFD700;
            text-shadow: 0 6px 0 #e67e22;
            transform: skew(-5deg) rotate(-2deg);
            text-align: center;
            line-height: 1;
        }

        .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.9;
            font-style: italic;
            color: #ddd;
        }

        input#username {
            padding: 15px;
            border-radius: 12px;
            border: 3px solid #FFD700;
            font-size: 20px;
            text-align: center;
            margin-bottom: 20px;
            width: 260px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-weight: bold;
            text-transform: uppercase;
            background: rgba(255,255,255,0.95);
            outline: none;
        }

        .btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            border: none;
            padding: 18px 80px;
            font-size: 26px;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #1e8449, 0 15px 20px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 2px 0 #1e8449;
        }

        .leaderboard-box {
            background: rgba(0,0,0,0.5);
            border-radius: 15px;
            padding: 15px;
            width: 85%;
            max-width: 350px;
            margin-bottom: 25px;
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(5px);
        }
        
        .lb-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-family: monospace;
            font-size: 16px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display" class="hud-stat">0</div>
            <div id="coins-display" class="hud-stat"><span style="font-size:24px">ðŸª™</span> 0</div>
        </div>
    </div>

    <!-- ECRAN ACCUEIL -->
    <div id="start-screen" class="screen">
        <h1>Subway<br>Stable</h1>
        <div class="subtitle">En Beta</div>
        
        <input type="text" id="username" placeholder="TON PSEUDO" maxlength="10">
        
        <div class="leaderboard-box">
            <div style="text-align:center; font-weight:bold; margin-bottom:10px; color:#FFD700; text-transform:uppercase;">Classement</div>
            <div id="lb-content">Chargement...</div>
        </div>

        <button class="btn" onclick="startGame()">JOUER</button>
    </div>

    <!-- ECRAN FIN -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 5px 0 #c0392b;">ATTRAPÃ‰ !</h1>
        <div style="font-size: 24px; margin-bottom: 20px;">Score: <span id="final-score" style="font-weight:bold; color:#FFD700;">0</span></div>
        <button class="btn" onclick="resetGame()">REJOUER</button>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            lanes: [-3.0, 0, 3.0], 
            colors: {
                sky: 0x87CEEB,
                ground: 0x5d4037,
                rails: 0x888888,
                wood: 0x3e2723,
                coin: 0xFFD700
            },
            speed: { start: 22, max: 22, accel: 0 }, 
            physics: { 
                gravity: 75, 
                jumpForce: 18, 
                laneSpeed: 18
            },
            segmentLength: 30
        };

        // --- ETAT ---
        const state = {
            isPlaying: false,
            score: 0,
            coins: 0,
            distance: 0,
            speed: CONFIG.speed.start,
            lane: 1,
            targetX: 0,
            playerY: 0,
            velY: 0,
            isJumping: false,
            isRolling: false,
            rollTimer: 0,
            username: 'Joueur',
            runAnimTimer: 0,
            lastSafeLane: 1,
            lastSpawnZ: 0 // RÃ©fÃ©rence pour le prochain spawn
        };

        // --- MOTEUR ---
        let scene, camera, renderer, clock;
        let player, playerMesh, guard;
        let activeObjects = []; 
        let sharedMaterials = {};
        let sharedGeometries = {};
        
        const pool = { 
            ground: [], trains: [], barriers: [], coins: [], catenary: [], buildings: [], trees: []
        }; 

        let leaderboards = JSON.parse(localStorage.getItem('subwayStableScores')) || [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            scene.fog = new THREE.Fog(CONFIG.colors.sky, 30, 110);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 250);
            camera.position.set(0, 5.5, 8);
            camera.lookAt(0, 1, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('game-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // LumiÃ¨res
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(40, 60, 20);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 1024;
            sun.shadow.mapSize.height = 1024;
            sun.shadow.camera.far = 120;
            sun.shadow.camera.left = -20;
            sun.shadow.camera.right = 20;
            sun.shadow.camera.top = 30;
            sun.shadow.camera.bottom = -10;
            scene.add(sun);

            initSharedAssets();
            createPlayer();
            createGuard();
            prewarmPools();
            updateLeaderboardUI();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', handleKey);
            
            // Touch Controls
            let tsX, tsY;
            document.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; tsY = e.touches[0].clientY; }, {passive: false});
            document.addEventListener('touchmove', e => e.preventDefault(), {passive: false});
            document.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - tsX;
                const dy = e.changedTouches[0].clientY - tsY;
                if(Math.abs(dx) > Math.abs(dy)) {
                    if(Math.abs(dx) > 30) changeLane(dx > 0 ? 1 : -1);
                } else {
                    if(Math.abs(dy) > 30) dy < 0 ? jump() : roll();
                }
            }, {passive: false});

            animate();
        }

        function initSharedAssets() {
            sharedMaterials.trainBody = new THREE.MeshStandardMaterial({color: 0xe74c3c, roughness: 0.3});
            sharedMaterials.trainBase = new THREE.MeshStandardMaterial({color: 0x2c3e50});
            sharedMaterials.win = new THREE.MeshStandardMaterial({color: 0x34495e});
            sharedMaterials.coin = new THREE.MeshStandardMaterial({color: 0xFFD700, metalness: 0.8, roughness: 0.2});
            sharedMaterials.barrier = new THREE.MeshStandardMaterial({color: 0xe67e22});
            sharedMaterials.wood = new THREE.MeshStandardMaterial({color: CONFIG.colors.wood});
            sharedMaterials.metal = new THREE.MeshStandardMaterial({color: 0x7f8c8d});
            sharedMaterials.treeTrunk = new THREE.MeshStandardMaterial({color: 0x795548});
            sharedMaterials.treeLeaves = new THREE.MeshStandardMaterial({color: 0x27ae60});
            sharedMaterials.ground = new THREE.MeshStandardMaterial({color: CONFIG.colors.ground});
            
            sharedGeometries.coin = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 12);
            sharedGeometries.coin.rotateX(Math.PI/2);
            sharedGeometries.barrierBar = new THREE.BoxGeometry(2.8, 0.9, 0.2);
            sharedGeometries.barrierLeg = new THREE.BoxGeometry(0.25, 1.3, 0.25);
            sharedGeometries.trainBody = new THREE.BoxGeometry(2.7, 3.2, 11);
        }

        function createPlayer() {
            player = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(0.7, 1.4, 0.5);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3498db }); 
            playerMesh = new THREE.Mesh(bodyGeo, bodyMat);
            playerMesh.position.y = 0.7;
            playerMesh.castShadow = true;
            
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({color: 0xffccaa}));
            head.position.y = 1.0;
            playerMesh.add(head);

            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.15, 0.6), new THREE.MeshStandardMaterial({color: 0xe74c3c}));
            cap.position.set(0, 0.3, -0.1);
            head.add(cap);

            player.add(playerMesh);
            scene.add(player);
        }

        function createGuard() {
            guard = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({color: 0x2c3e50});
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.6, 0.7), mat);
            body.position.y = 0.8;
            body.castShadow = true;
            const dog = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.8), new THREE.MeshStandardMaterial({color: 0x8d6e63}));
            dog.position.set(0.8, 0.25, 0);
            dog.castShadow = true;
            guard.add(body);
            guard.add(dog);
            guard.position.set(0, 0, 4);
            scene.add(guard);
        }

        function prewarmPools() {
            const createAndAdd = (fn) => {
                const obj = fn();
                obj.visible = false;
                scene.add(obj);
                return obj;
            };

            for(let i=0; i<45; i++) pool.ground.push(createAndAdd(createGround));
            for(let i=0; i<15; i++) pool.trains.push(createAndAdd(createTrain));
            for(let i=0; i<25; i++) pool.barriers.push(createAndAdd(createBarrier));
            for(let i=0; i<80; i++) pool.coins.push(createAndAdd(createCoin));
            for(let i=0; i<20; i++) pool.catenary.push(createAndAdd(createCatenary));
            for(let i=0; i<50; i++) pool.buildings.push(createAndAdd(createBuilding));
            for(let i=0; i<50; i++) pool.trees.push(createAndAdd(createTree));
        }

        function createGround() {
            const g = new THREE.Group();
            // 30.5m de long pour 30m d'Ã©cartement = Recouvrement parfait (pas de trous)
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(12, 30.5), sharedMaterials.ground); 
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            g.add(floor);
            const railGeo = new THREE.BoxGeometry(0.1, 0.15, 30);
            const sleeperGeo = new THREE.BoxGeometry(2.4, 0.1, 0.4);
            CONFIG.lanes.forEach(x => {
                const r1 = new THREE.Mesh(railGeo, sharedMaterials.metal);
                r1.position.set(x-0.8, 0.1, 0);
                g.add(r1);
                const r2 = r1.clone();
                r2.position.set(x+0.8, 0.1, 0);
                g.add(r2);
                for(let k=0; k<12; k++) {
                    const s = new THREE.Mesh(sleeperGeo, sharedMaterials.wood);
                    s.position.set(x, 0.06, -14 + k*2.5);
                    g.add(s);
                }
            });
            return g;
        }

        function createTrain() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(sharedGeometries.trainBody, sharedMaterials.trainBody);
            body.position.y = 2.0;
            body.castShadow = true;
            g.add(body);
            const wGeo = new THREE.BoxGeometry(3, 0.6, 8);
            const wheels = new THREE.Mesh(wGeo, sharedMaterials.trainBase);
            wheels.position.y = 0.3;
            g.add(wheels);
            const win = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1, 0.1), sharedMaterials.win);
            win.position.set(0, 2.5, 5.51);
            g.add(win);
            g.userData = {type: 'obstacle', hit: {w:2.4, h:3.4, d:10.5}};
            return g;
        }

        function createBarrier() {
            const g = new THREE.Group();
            const bar = new THREE.Mesh(sharedGeometries.barrierBar, sharedMaterials.barrier);
            bar.position.y = 1.1;
            bar.castShadow = true;
            g.add(bar);
            const l1 = new THREE.Mesh(sharedGeometries.barrierLeg, sharedMaterials.metal);
            l1.position.set(-1.2, 0.65, 0);
            g.add(l1);
            const l2 = l1.clone();
            l2.position.set(1.2, 0.65, 0);
            g.add(l2);
            g.userData = {type: 'obstacle', hit: {w:2.4, h:0.9, d:2.0}};
            return g;
        }

        function createCoin() {
            const c = new THREE.Mesh(sharedGeometries.coin, sharedMaterials.coin);
            c.userData = {type: 'coin'};
            return c;
        }

        function createCatenary() {
            const g = new THREE.Group();
            const p1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 8, 0.4), sharedMaterials.metal);
            p1.position.set(-6, 4, 0);
            g.add(p1);
            const p2 = p1.clone();
            p2.position.set(6, 4, 0);
            g.add(p2);
            const top = new THREE.Mesh(new THREE.BoxGeometry(12.5, 0.3, 0.3), sharedMaterials.metal);
            top.position.set(0, 7.5, 0);
            g.add(top);
            return g;
        }

        function createBuilding() {
            const h = 8 + Math.random() * 12;
            const geo = new THREE.BoxGeometry(5, h, 5);
            const mat = new THREE.MeshStandardMaterial({color: Math.random() > 0.5 ? 0xf1c40f : 0xe74c3c});
            const m = new THREE.Mesh(geo, mat);
            m.position.y = h/2;
            m.castShadow = true;
            return m;
        }

        function createTree() {
            const g = new THREE.Group();
            const t = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 2), sharedMaterials.treeTrunk);
            t.position.y = 1;
            g.add(t);
            const l = new THREE.Mesh(new THREE.DodecahedronGeometry(1.8), sharedMaterials.treeLeaves);
            l.position.y = 2.5;
            g.add(l);
            return g;
        }

        function getFromPool(arr) {
            const obj = arr.find(o => !o.visible);
            if(obj) { obj.visible = true; return obj; }
            return null;
        }

        function spawnSegment(z) {
            const g = getFromPool(pool.ground);
            if(g) { g.position.set(0, 0, z); activeObjects.push(g); }
            
            if(Math.random() > 0.4) {
                const c = getFromPool(pool.catenary);
                if(c) { c.position.set(0, 0, z); activeObjects.push(c); }
            }
            const left = Math.random() > 0.5 ? getFromPool(pool.buildings) : getFromPool(pool.trees);
            if(left) { left.position.set(-11 - Math.random()*2, 0, z); activeObjects.push(left); }
            const right = Math.random() > 0.5 ? getFromPool(pool.buildings) : getFromPool(pool.trees);
            if(right) { right.position.set(11 + Math.random()*2, 0, z); activeObjects.push(right); }

            if(z > -40) return; 

            let possibleSafeLanes = [];
            if (state.lastSafeLane === 0) possibleSafeLanes = [0, 1];
            else if (state.lastSafeLane === 1) possibleSafeLanes = [0, 1, 2];
            else if (state.lastSafeLane === 2) possibleSafeLanes = [1, 2];
            const newSafeLane = possibleSafeLanes[Math.floor(Math.random() * possibleSafeLanes.length)];
            state.lastSafeLane = newSafeLane;
            
            for(let i=0; i<3; i++) {
                const laneIdx = i; 
                const x = CONFIG.lanes[laneIdx];
                if(laneIdx === newSafeLane) {
                    if(Math.random() > 0.3) {
                        for(let k=0; k<4; k++) {
                            const c = getFromPool(pool.coins);
                            if(c) { c.position.set(x, 1.2, z - 10 + k*4); activeObjects.push(c); }
                        }
                    }
                } else {
                    const r = Math.random();
                    if(r < 0.35) { 
                        const t = getFromPool(pool.trains);
                        if(t) { t.position.set(x, 0, z); t.userData.speed = (Math.random() < 0.2) ? 12 : 0; activeObjects.push(t); }
                    } else if(r < 0.65) { 
                        const b = getFromPool(pool.barriers);
                        if(b) { b.position.set(x, 0, z); activeObjects.push(b); }
                    }
                }
            }
        }

        function update(dt) {
            if(!state.isPlaying) return;

            const distStep = state.speed * dt;
            state.distance += distStep;
            state.score = Math.floor(state.distance);
            document.getElementById('score-display').innerText = state.score;

            // --- REPARATION CRITIQUE DE LA MAP ---
            // On dÃ©place aussi le point de spawn avec le monde !
            state.lastSpawnZ += distStep;

            // Si le bout de la map se rapproche trop (moins de 180m), on rajoute un segment
            while (state.lastSpawnZ > -180) {
                spawnSegment(state.lastSpawnZ);
                state.lastSpawnZ -= CONFIG.segmentLength;
            }

            // Mise Ã  jour de tous les objets actifs
            for(let i = activeObjects.length - 1; i >= 0; i--) {
                const obj = activeObjects[i];
                if(!obj.visible) continue;
                
                let zMove = distStep;
                if(obj.userData.speed) zMove += obj.userData.speed * dt;
                obj.position.z += zMove;

                if(obj.userData.type === 'coin') obj.rotation.y += 5 * dt;

                if(checkCollision(obj)) {
                    if(obj.userData.type === 'coin') {
                        state.coins++;
                        document.getElementById('coins-display').innerText = `ðŸª™ ${state.coins}`;
                        obj.visible = false;
                    } else if(obj.userData.type === 'obstacle') {
                        gameOver();
                    }
                }

                // Recyclage : on cache l'objet quand il est loin derriÃ¨re la camÃ©ra (Z > 35)
                if(obj.position.z > 35) {
                    obj.visible = false;
                    activeObjects.splice(i, 1);
                }
            }

            // Physique Joueur
            state.targetX = CONFIG.lanes[state.lane];
            const moveStep = (state.targetX - player.position.x) * CONFIG.physics.laneSpeed * dt;
            player.position.x += moveStep;
            player.rotation.z = -moveStep * 0.15;
            player.rotation.y = -moveStep * 0.1;
            
            state.runAnimTimer += dt * 15;
            let bounce = Math.sin(state.runAnimTimer) * 0.05;

            if(state.isJumping) {
                state.playerY += state.velY * dt;
                state.velY -= CONFIG.physics.gravity * dt;
                if(state.playerY <= 0) {
                    state.playerY = 0;
                    state.isJumping = false;
                    playerMesh.position.y = 0.7;
                }
                bounce = 0;
            } else if (state.isRolling) {
                state.rollTimer -= dt;
                playerMesh.scale.y = 0.5;
                playerMesh.position.y = 0.35;
                if(state.rollTimer <= 0) {
                    state.isRolling = false;
                    playerMesh.scale.y = 1;
                    playerMesh.position.y = 0.7;
                }
                bounce = 0;
            }
            player.position.y = state.playerY + bounce;

            // Garde
            let guardZ = 3.5;
            if(state.isJumping || state.isRolling) guardZ = 2.5; 
            guard.position.z += (guardZ - guard.position.z) * 2 * dt;
            guard.position.x += (player.position.x - guard.position.x) * 5 * dt;
        }

        function checkCollision(obj) {
            if(!obj.visible) return false;
            const pBox = new THREE.Box3().setFromObject(playerMesh);
            pBox.expandByScalar(-0.35); 
            const oBox = new THREE.Box3().setFromObject(obj);
            const shrinkX = -0.3;
            const shrinkY = -0.1;
            const shrinkZ = -0.1;
            oBox.min.x -= shrinkX; oBox.max.x += shrinkX;
            oBox.min.y -= shrinkY; oBox.max.y += shrinkY;
            oBox.min.z -= shrinkZ; oBox.max.z += shrinkZ;
            return pBox.intersectsBox(oBox);
        }

        function handleKey(e) {
            if(!state.isPlaying) return;
            if(e.key === 'ArrowLeft' || e.key === 'q') changeLane(-1);
            if(e.key === 'ArrowRight' || e.key === 'd') changeLane(1);
            if(e.key === 'ArrowUp' || e.key === 'z') jump();
            if(e.key === 'ArrowDown' || e.key === 's') roll();
        }

        function changeLane(dir) {
            const next = state.lane + dir;
            if(next >= 0 && next <= 2) state.lane = next;
        }

        function jump() {
            if(!state.isJumping) {
                state.isJumping = true;
                state.velY = CONFIG.physics.jumpForce;
                state.isRolling = false;
            }
        }

        function roll() {
            if(!state.isRolling && !state.isJumping) {
                state.isRolling = true;
                state.rollTimer = 0.8;
                state.velY = -15; 
            }
        }

        function startGame() {
            const inputName = document.getElementById('username').value.trim();
            state.username = inputName || "Joueur";
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            // RESET COMPLET
            activeObjects.forEach(o => o.visible = false);
            activeObjects = [];
            state.distance = 0;
            state.score = 0;
            state.coins = 0;
            state.speed = CONFIG.speed.start;
            state.isPlaying = true;
            state.lane = 1;
            state.targetX = 0;
            state.lastSpawnZ = 0;
            player.position.set(0,0,0);
            
            // On remplit le monde initialement jusqu'Ã  210m (7 segments)
            while (state.lastSpawnZ > -210) {
                spawnSegment(state.lastSpawnZ);
                state.lastSpawnZ -= CONFIG.segmentLength;
            }
        }

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            saveScore(state.username, state.score);
            updateLeaderboardUI();
        }

        function resetGame() {
            startGame();
        }

        function saveScore(name, score) {
            const existing = leaderboards.find(l => l.name === name);
            if(existing) {
                if(score > existing.score) existing.score = score;
            } else {
                leaderboards.push({name, score});
            }
            leaderboards.sort((a,b) => b.score - a.score);
            leaderboards = leaderboards.slice(0, 10);
            localStorage.setItem('subwayStableScores', JSON.stringify(leaderboards));
        }

        function updateLeaderboardUI() {
            const div = document.getElementById('lb-content');
            if(leaderboards.length === 0) {
                div.innerHTML = "<div style='text-align:center; color:#ccc; font-style:italic; padding:10px'>Aucun record enregistrÃ©</div>";
                return;
            }
            div.innerHTML = leaderboards.map((l, i) => `
                <div class="lb-row">
                    <span>${i+1}. ${l.name}</span>
                    <span style="color:#FFD700">${l.score}</span>
                </div>
            `).join('');
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            if(state.isPlaying) update(dt);
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
