<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Waajk Surfer - ULTIMATE EDITION</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Arial Rounded MT Bold', 'Helvetica', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .hud-stat {
            font-weight: 900;
            font-size: 36px;
            color: white;
            -webkit-text-stroke: 2px #000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #3498db 0%, #2c3e50 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .hidden { opacity: 0; pointer-events: none; }

        h1 {
            font-size: 80px;
            margin-bottom: 0;
            color: #f1c40f;
            text-shadow: 0 8px 0 #d35400, 0 15px 20px rgba(0,0,0,0.4);
            transform: skew(-5deg) rotate(-2deg);
            text-align: center;
            line-height: 0.9;
        }

        .subtitle {
            font-size: 20px;
            margin-top: 20px;
            margin-bottom: 40px;
            background: rgba(0,0,0,0.2);
            padding: 5px 20px;
            border-radius: 20px;
            font-weight: bold;
        }

        .btn {
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            border: none;
            padding: 20px 80px;
            font-size: 32px;
            color: white;
            border-radius: 60px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 8px 0 #1e8449, 0 15px 25px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #1e8449;
        }

        .leaderboard {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 20px;
            width: 80%;
            max-width: 350px;
            margin-bottom: 30px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .lb-row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            margin: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 4px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display" class="hud-stat">0</div>
            <div id="coins-display" class="hud-stat" style="color:#FFD700">ðŸª™ 0</div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>Waajk<br>Surfer</h1>
        <div class="subtitle">L'EDITION ULTIME</div>
        <div class="leaderboard">
            <div style="text-align:center; font-weight:bold; color:#FFD700; margin-bottom:15px; text-transform:uppercase;">Meilleurs Scores</div>
            <div id="lb-content">Aucun record</div>
        </div>
        <button class="btn" onclick="startGame()">SURF !</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color: #e74c3c; text-shadow: 0 8px 0 #c0392b;">STOP !</h1>
        <div style="font-size: 32px; margin: 30px 0;">SCORE : <span id="final-score" style="color:#FFD700">0</span></div>
        <button class="btn" onclick="resetGame()">REJOUER</button>
    </div>

    <script>
        /**
         * WAAJK SURFER - CONFIGURATION GLOBALE
         */
        const CONFIG = {
            lanes: [-3.8, 0, 3.8],
            colors: {
                sky: 0x87CEEB,
                ground: 0x333333,
                sidewalk: 0x7f8c8d,
                trainRed: 0xd35400,
                trainGreen: 0x27ae60,
                trainBlue: 0x2980b9,
                coin: 0xf1c40f
            },
            physics: {
                gravity: 125,
                jumpForce: 26,
                laneSpeed: 22,
                fastFall: -55
            },
            speed: 26,
            segmentLength: 30
        };

        const state = {
            isPlaying: false,
            score: 0,
            coins: 0,
            distance: 0,
            lane: 1,
            playerY: 0,
            velY: 0,
            isJumping: false,
            isRolling: false,
            rollTimer: 0,
            lastSpawnZ: 0,
            currentSurfaceY: 0,
            animTimer: 0
        };

        let scene, camera, renderer, clock;
        let playerGroup, playerBody, guard;
        let leftArm, rightArm, leftLeg, rightLeg;
        let activeObjects = [];

        /**
         * INITIALISATION DU MOTEUR
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.sky);
            scene.fog = new THREE.Fog(CONFIG.colors.sky, 50, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
            camera.position.set(0, 7, 10);
            camera.lookAt(0, 2, -10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1.0);
            sun.position.set(60, 100, 40);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.camera.far = 250;
            scene.add(sun);

            createPlayer();
            createGuard();
            updateLeaderboardUI();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', handleKey);
            
            // ContrÃ´les tactiles (Swipes)
            let startX, startY;
            document.addEventListener('touchstart', e => { startX = e.touches[0].clientX; startY = e.touches[0].clientY; }, {passive: false});
            document.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - startX;
                const dy = e.changedTouches[0].clientY - startY;
                if(Math.abs(dx) > Math.abs(dy)) {
                    if(Math.abs(dx) > 30) moveLane(dx > 0 ? 1 : -1);
                } else {
                    if(Math.abs(dy) > 30) dy < 0 ? jump() : roll();
                }
            });

            clock = new THREE.Clock();
            animate();
        }

        /**
         * CRÃ‰ATION DU PERSONNAGE AVEC MEMBRES
         */
        function createPlayer() {
            playerGroup = new THREE.Group();
            playerBody = new THREE.Group();
            playerBody.position.y = 1.1;

            const matShirt = new THREE.MeshStandardMaterial({color: 0xecf0f1});
            const matSkin = new THREE.MeshStandardMaterial({color: 0xffccaa});
            const matJeans = new THREE.MeshStandardMaterial({color: 0x2980b9});

            // Torse
            const torse = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.85, 0.4), matShirt);
            torse.castShadow = true;
            playerBody.add(torse);

            // TÃªte
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), matSkin);
            head.position.y = 0.7;
            torse.add(head);

            // Casquette
            const cap = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.12, 0.65), new THREE.MeshStandardMaterial({color: 0xe74c3c}));
            cap.position.set(0, 0.28, -0.05);
            head.add(cap);

            // Bras articulÃ©s
            const armGeo = new THREE.BoxGeometry(0.2, 0.65, 0.2);
            leftArm = new THREE.Mesh(armGeo, matShirt);
            leftArm.position.set(-0.45, 0.1, 0);
            torse.add(leftArm);
            rightArm = new THREE.Mesh(armGeo, matShirt);
            rightArm.position.set(0.45, 0.1, 0);
            torse.add(rightArm);

            // Jambes
            const legGeo = new THREE.BoxGeometry(0.25, 0.75, 0.25);
            leftLeg = new THREE.Mesh(legGeo, matJeans);
            leftLeg.position.set(-0.2, -0.75, 0);
            torse.add(leftLeg);
            rightLeg = new THREE.Mesh(legGeo, matJeans);
            rightLeg.position.set(0.2, -0.75, 0);
            torse.add(rightLeg);

            playerGroup.add(playerBody);
            scene.add(playerGroup);
        }

        function createGuard() {
            guard = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.9), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            body.position.y = 1.1;
            guard.add(body);
            guard.position.z = 6;
            scene.add(guard);
        }

        /**
         * CONSTRUCTION DES MODÃˆLES DÃ‰TAILLÃ‰S
         */
        function createDetailedTrain(isRamp) {
            const g = new THREE.Group();
            const color = isRamp ? CONFIG.colors.trainGreen : (Math.random() > 0.5 ? CONFIG.colors.trainRed : CONFIG.colors.trainBlue);
            
            // Corps principal
            const body = new THREE.Mesh(new THREE.BoxGeometry(3, 3.6, 12), new THREE.MeshStandardMaterial({color, roughness: 0.3}));
            body.position.y = 1.8;
            body.castShadow = true;
            g.add(body);

            // FenÃªtres
            const winGeo = new THREE.BoxGeometry(3.1, 1.2, 2);
            const winMat = new THREE.MeshStandardMaterial({color: 0x34495e, metalness: 0.8});
            for(let k=0; k<3; k++) {
                const w = new THREE.Mesh(winGeo, winMat);
                w.position.set(0, 2.2, -3.5 + k*3.5);
                g.add(w);
            }

            // Rampe
            if(isRamp) {
                const ramp = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 6), new THREE.MeshStandardMaterial({color}));
                ramp.position.set(0, 1.7, 8.5);
                ramp.rotation.x = 0.55;
                g.add(ramp);
            }
            
            // Toit contrastÃ©
            const roof = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.1, 11.8), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
            roof.position.y = 3.65;
            g.add(roof);

            g.userData = { type: 'obstacle', subtype: 'train', isRamp, h: 3.6 };
            return g;
        }

        function createDetailedBarrier() {
            const g = new THREE.Group();
            // Barre avec bandes jaunes/noires
            const bar = new THREE.Mesh(new THREE.BoxGeometry(3.4, 0.8, 0.35), new THREE.MeshStandardMaterial({color: 0xf1c40f}));
            bar.position.y = 1.25;
            g.add(bar);
            
            // Bandes de dÃ©co
            for(let i=0; i<4; i++) {
                const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.82, 0.38), new THREE.MeshStandardMaterial({color: 0x222222}));
                stripe.position.set(-1.2 + i*0.8, 1.25, 0);
                g.add(stripe);
            }

            const l1 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.6, 0.35), new THREE.MeshStandardMaterial({color: 0x7f8c8d}));
            l1.position.set(-1.4, 0.8, 0); g.add(l1);
            const l2 = l1.clone(); l2.position.x = 1.4; g.add(l2);
            
            g.userData = { type: 'obstacle', subtype: 'barrier', h: 1.65 };
            return g;
        }

        /**
         * GÃ‰NÃ‰RATION DE LA MAP
         */
        function spawnSegment(z) {
            // Zone de rails
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(16, 30.2), new THREE.MeshStandardMaterial({color: 0x222222}));
            floor.rotation.x = -Math.PI/2;
            floor.position.z = z;
            floor.receiveShadow = true;
            scene.add(floor);
            activeObjects.push(floor);

            // Trottoirs
            const sidewalkL = new THREE.Mesh(new THREE.PlaneGeometry(8, 30.2), new THREE.MeshStandardMaterial({color: 0x7f8c8d}));
            sidewalkL.rotation.x = -Math.PI/2;
            sidewalkL.position.set(-12, 0.1, z);
            scene.add(sidewalkL);
            activeObjects.push(sidewalkL);
            
            const sidewalkR = sidewalkL.clone();
            sidewalkR.position.x = 12;
            scene.add(sidewalkR);
            activeObjects.push(sidewalkR);

            if(z > -30) return;

            // DÃ©coration : Lampadaires & BÃ¢timents
            if(Math.random() > 0.4) {
                const lamp = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 10), new THREE.MeshStandardMaterial({color: 0x34495e}));
                pole.position.set(-9, 5, z);
                lamp.add(pole);
                const light = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1), new THREE.MeshStandardMaterial({color: 0xf1c40f, emissive: 0xf1c40f}));
                light.position.set(-8.2, 9.8, z);
                lamp.add(light);
                scene.add(lamp);
                activeObjects.push(lamp);
            }

            const h = 15 + Math.random() * 25;
            const house = new THREE.Mesh(new THREE.BoxGeometry(8, h, 8), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL(Math.random(), 0.5, 0.5)}));
            house.position.set(Math.random() > 0.5 ? 18 : -18, h/2, z);
            scene.add(house);
            activeObjects.push(house);

            // Obstacles logiques
            const lanes = [0, 1, 2].sort(() => Math.random() - 0.5);
            const pattern = Math.random();

            for(let i=0; i<2; i++) { 
                const lane = lanes[i];
                const x = CONFIG.lanes[lane];
                let obj;

                if(pattern < 0.5) {
                    obj = createDetailedTrain(Math.random() > 0.6);
                } else {
                    obj = createDetailedBarrier();
                }

                obj.position.set(x, 0, z);
                scene.add(obj);
                activeObjects.push(obj);

                // PiÃ¨ces sur les trains ou au sol
                if(obj.userData.subtype === 'train' && Math.random() > 0.3) {
                    for(let k=0; k<4; k++) {
                        const coin = createCoin();
                        coin.position.set(x, 4.8, z - 4 + k*3.5);
                        scene.add(coin);
                        activeObjects.push(coin);
                    }
                }
            }

            // PiÃ¨ces dans la voie libre
            const freeLaneX = CONFIG.lanes[lanes[2]];
            if(Math.random() > 0.3) {
                for(let k=0; k<5; k++) {
                    const coin = createCoin();
                    coin.position.set(freeLaneX, 1.3, z - 10 + k*4);
                    scene.add(coin);
                    activeObjects.push(coin);
                }
            }
        }

        function createCoin() {
            const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.15, 16), new THREE.MeshStandardMaterial({color: CONFIG.colors.coin, metalness: 0.7}));
            coin.rotation.x = Math.PI/2;
            coin.userData = { type: 'coin' };
            return coin;
        }

        /**
         * BOUCLE DE MISE Ã€ JOUR
         */
        function update(dt) {
            if(!state.isPlaying) return;

            const step = CONFIG.speed * dt;
            state.distance += step;
            state.score = Math.floor(state.distance);
            document.getElementById('score-display').innerText = state.score;

            state.lastSpawnZ += step;
            while(state.lastSpawnZ > -200) {
                spawnSegment(state.lastSpawnZ);
                state.lastSpawnZ -= CONFIG.segmentLength;
            }

            let foundSurfaceY = 0;

            for(let i=activeObjects.length-1; i>=0; i--) {
                const obj = activeObjects[i];
                obj.position.z += step;

                // Rotation des piÃ¨ces
                if(obj.userData.type === 'coin') {
                    obj.rotation.y += 6 * dt;
                    if(checkCollision(obj, 1.0, 1.8)) {
                        state.coins++;
                        document.getElementById('coins-display').innerText = `ðŸª™ ${state.coins}`;
                        scene.remove(obj);
                        activeObjects.splice(i, 1);
                        continue;
                    }
                }

                // Collisions obstacles & Plateformes
                if(obj.userData.type === 'obstacle') {
                    const col = checkAdvancedCollision(obj);
                    if(col) {
                        if(col.type === 'surface') {
                            foundSurfaceY = Math.max(foundSurfaceY, col.y);
                        } else if(col.type === 'ramp') {
                            state.playerY = col.y;
                            foundSurfaceY = Math.max(foundSurfaceY, col.y);
                        } else {
                            gameOver();
                        }
                    }
                }

                // Nettoyage
                if(obj.position.z > 60) {
                    scene.remove(obj);
                    activeObjects.splice(i, 1);
                }
            }

            state.currentSurfaceY = foundSurfaceY;

            // Mouvement latÃ©ral
            const targetX = CONFIG.lanes[state.lane];
            playerGroup.position.x += (targetX - playerGroup.position.x) * CONFIG.physics.laneSpeed * dt;
            playerBody.rotation.z = (playerGroup.position.x - targetX) * 0.12;

            // Animation course
            state.animTimer += dt * 18;
            let bounce = 0;
            if(!state.isJumping && !state.isRolling) {
                bounce = Math.sin(state.animTimer) * 0.1;
                const angle = Math.sin(state.animTimer) * 0.8;
                leftArm.rotation.x = -angle; rightArm.rotation.x = angle;
                leftLeg.rotation.x = angle; rightLeg.rotation.x = -angle;
            }

            // GravitÃ© et Atterrissage
            if(state.isJumping) {
                state.playerY += state.velY * dt;
                state.velY -= CONFIG.physics.gravity * dt;
                if(state.velY < 0 && state.playerY <= state.currentSurfaceY) {
                    state.playerY = state.currentSurfaceY;
                    state.isJumping = false;
                }
            } else {
                if(state.playerY > state.currentSurfaceY + 0.15) {
                    state.isJumping = true; state.velY = 0;
                } else {
                    state.playerY = state.currentSurfaceY;
                }
            }

            // Roulade
            if(state.isRolling) {
                state.rollTimer -= dt;
                const p = 1.0 - (state.rollTimer / 0.5);
                playerBody.rotation.x = -Math.PI * 2 * p;
                playerBody.position.y = 0.55;
                if(state.rollTimer <= 0) {
                    state.isRolling = false;
                    playerBody.rotation.x = 0;
                    playerBody.position.y = 1.1;
                }
            }

            playerGroup.position.y = state.playerY + bounce;
            
            // CamÃ©ra dynamique
            camera.position.x += (playerGroup.position.x * 0.6 - camera.position.x) * 4 * dt;
            guard.position.x += (playerGroup.position.x - guard.position.x) * 6 * dt;
        }

        /**
         * LOGIQUE DE COLLISION AVANCÃ‰E
         */
        function checkCollision(obj, rx, ry) {
            const dx = Math.abs(playerGroup.position.x - obj.position.x);
            const dy = Math.abs((state.playerY + 1.2) - obj.position.y);
            const dz = Math.abs(obj.position.z);
            return dx < rx && dy < ry && dz < 1.2;
        }

        function checkAdvancedCollision(obj) {
            const dx = Math.abs(playerGroup.position.x - obj.position.x);
            const dz = Math.abs(obj.position.z);
            if(dx > 1.8 || dz > 6.5) return null;

            if(obj.userData.subtype === 'train') {
                // Gestion de la rampe
                if(obj.userData.isRamp) {
                    const distToFront = (obj.position.z + 6) - playerGroup.position.z;
                    if(distToFront > 0 && distToFront < 6 && dx < 1.5) {
                        return { type: 'ramp', y: (distToFront / 6) * 3.6 };
                    }
                }
                // Marcher sur le toit
                if(state.playerY >= 3.2 && dz < 6.2 && dx < 1.5) return { type: 'surface', y: 3.6 };
                // Crash
                if(dz < 6.0 && dx < 1.5) return { type: 'hit' };
            }

            if(obj.userData.subtype === 'barrier') {
                // Sauter sur la barriÃ¨re
                if(state.playerY >= 1.4 && dz < 0.6 && dx < 1.6) return { type: 'surface', y: 1.65 };
                // Crash
                if(dz < 0.5 && dx < 1.6) return { type: 'hit' };
            }
            return null;
        }

        /**
         * CONTRÃ”LES ET Ã‰VÃ‰NEMENTS
         */
        function handleKey(e) {
            if(!state.isPlaying) return;
            if(e.key === 'ArrowLeft' || e.key === 'q') moveLane(-1);
            if(e.key === 'ArrowRight' || e.key === 'd') moveLane(1);
            if(e.key === 'ArrowUp' || e.key === 'z') jump();
            if(e.key === 'ArrowDown' || e.key === 's') roll();
        }

        function moveLane(dir) {
            state.lane = Math.max(0, Math.min(2, state.lane + dir));
        }

        function jump() {
            if(!state.isJumping && !state.isRolling) {
                state.isJumping = true; state.velY = CONFIG.physics.jumpForce;
            }
        }

        function roll() {
            if(state.isJumping) { 
                state.isJumping = false; 
                state.velY = CONFIG.physics.fastFall; 
            }
            if(!state.isRolling) { 
                state.isRolling = true; 
                state.rollTimer = 0.5; 
            }
        }

        /**
         * GESTION DES Ã‰TATS DE JEU
         */
        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            activeObjects.forEach(o => scene.remove(o));
            activeObjects = [];
            state.distance = 0; state.coins = 0; state.isPlaying = true;
            state.lane = 1; state.lastSpawnZ = 0; state.playerY = 0;
            playerGroup.position.set(0,0,0);
            while(state.lastSpawnZ > -240) { spawnSegment(state.lastSpawnZ); state.lastSpawnZ -= CONFIG.segmentLength; }
        }

        function gameOver() {
            state.isPlaying = false;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            const scores = JSON.parse(localStorage.getItem('waajkUltimateScores')) || [];
            scores.push(state.score);
            scores.sort((a,b) => b-a);
            localStorage.setItem('waajkUltimateScores', JSON.stringify(scores.slice(0, 5)));
            updateLeaderboardUI();
        }

        function resetGame() { startGame(); }

        function updateLeaderboardUI() {
            const scores = JSON.parse(localStorage.getItem('waajkUltimateScores')) || [];
            const div = document.getElementById('lb-content');
            div.innerHTML = scores.map((s, i) => `<div class="lb-row"><span>RANG #${i+1}</span><span>${s} pts</span></div>`).join('') || "Aucun record";
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            update(dt);
            renderer.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
